
/**
  * ANALIZADOR SINTACTICO DE UN LENGUAJE BSL
  *
  *
  */
  
package cup.example;
import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("prueba/vacio.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIV, MENOR, MAYOR, IGUAL,UMINUS,
					LPAREN, RPAREN, DPTOS, LCORCH, RCORCH, COMA, PUNTO, 
					AND, OR, NOT, DENTERO, DREAL, DCARACTER, DBOOLEAN, 
                    RETURN, FUNCION, MIENTRAS, FINMIENTRAS, STRUCT, SI, SINO, FINSI, ENTONCES,
                    MENORIGUAL, MAYORIGUAL, IGUALIGUAL, NOTIGUAL;
terminal Double 	NUMBER;
terminal Boolean    BOOLEAN;
terminal char       CHAR;
terminal String     ID;

/* Non terminals */
non terminal programa, blq_sentencias, sentencia, sent_decl, sent_uso, sent_flujo,
			 asignacion, condicional, keytipo, decl_variable, decl_struct,
			 identificado, bucle, lista_struct, decl_funcion, lexp,
			 type_struct, identificado_funcion, declaradores;
			 
non terminal  Boolean dec_exp_n1, dec_exp_n2, dec_exp_n3, dec_exp_n4, dec_exp_n5;

/* Precedencia */
precedence nonassoc LPAREN;	// Inserted by Eclipse plugin
precedence left NOT, AND, OR;
precedence left MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, IGUALIGUAL, NOTIGUAL ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

/* The grammar rules */

//Inicio del análisis del texto
programa ::= blq_sentencias 
		   | /*lambda*/
		   ;
 
//Para obtener si hay una sentencia (cosas ;) o es la última
blq_sentencias ::= blq_sentencias sentencia  
				 | sentencia
				 ;

//Tipos de sentencias que puede existir en el programa
sentencia ::= sent_decl //SENTENCIAS DE DECLARACION:
			| sent_uso //SENTENCIAS DE INICIALIZACION
			| sent_flujo //SENTENCIA DE FLUJO
			;

//SENTENCIAS DE DECLARACION:
sent_decl ::= decl_variable SEMI // KEYTIPO ID := valor; Ó KEYTIPO ID,...; 1 a N 
			| decl_struct		 // STRUCT ID LCORCH lista_struct RCORCH
			| decl_funcion		 //FUNCION 
			;

//SENTENCIA DE FLUJO
sent_flujo ::= condicional       //IF expresion ENTONCES BLOQUE SENTENCIAS ELSE BLOQUE FINSI      
			 | bucle			 //MIENTRAS BLOQUE FINMIENTRAS
			 ;
			
//SENTENCIAS DE INICIALIZACION
sent_uso ::= asignacion SEMI     // ID := valor; Ó ID.ID... := valor
		   | dec_exp_n1 SEMI	 // Una expresion tipo calculadora
		   ;


// KEYTIPO ID := valor; Ó KEYTIPO ID,...; 1 a N	 
decl_variable ::= keytipo ID DPTOS IGUAL dec_exp_n1 
				| keytipo identificado
				;

// Desde ID hasta ID, ID, ID,... 1 a N
identificado ::= identificado COMA ID
				| ID
				;	
				
//Estructura de un Struct
decl_struct ::= STRUCT ID LCORCH lista_struct RCORCH 
			  ;
  
//CONTENIDO DE UN STRUCT
lista_struct ::= decl_variable SEMI lista_struct
			   | decl_variable SEMI
			   ;
							
//DECLARAR UNA FUNCION
decl_funcion ::= FUNCION ID LPAREN identificado_funcion RPAREN RETURN keytipo LCORCH blq_sentencias RCORCH
		  	   ;

//PARAMETROS DE ENTRADA DE UNA FUNCION
identificado_funcion ::= declaradores
			   		   |
			           ;
			           
declaradores ::= declaradores COMA keytipo ID
			   	| keytipo ID
			   	;	           

//CONDICIONAL : IF expresion ENTONCES bloque (ELSE bloque) FINSI
condicional ::= SI dec_exp_n1 ENTONCES blq_sentencias FINSI
			  | SI dec_exp_n1 ENTONCES blq_sentencias SINO blq_sentencias FINSI
			  ;

//BUCLE: MIENTRAS expresion FINMIENTRAS
bucle ::= MIENTRAS dec_exp_n1 blq_sentencias FINMIENTRAS 
		;

//DEFINIDORES DE VARIABLES
keytipo ::= DENTERO 
		  | DREAL 
		  | DBOOLEAN 
		  | DCARACTER
		  | ID
		  ;
			
//USADO PARA LLAMAR FUNCIONES				
lexp ::= lexp COMA dec_exp_n1
	   | dec_exp_n1
	   ;
	   
// ID := valor; Ó ID.ID... := valor
asignacion ::= type_struct DPTOS IGUAL dec_exp_n1
			 ;
			 
//Desde ID hasta ID.ID.ID... de 1 a N
type_struct	::= type_struct PUNTO ID
			  | ID
			  ;	
		
//EXPRESIONES LOGICOARITMETICAS
dec_exp_n1 ::= dec_exp_n1 MENOR dec_exp_n1
		     | dec_exp_n1 MAYOR dec_exp_n1
		     | dec_exp_n1 MAYORIGUAL  dec_exp_n1
		     | dec_exp_n1 MENORIGUAL dec_exp_n1
		     | dec_exp_n1 IGUALIGUAL dec_exp_n1
		     | dec_exp_n1 NOTIGUAL dec_exp_n1
		     | dec_exp_n2
		     ;

dec_exp_n2 ::= dec_exp_n2 PLUS dec_exp_n2
			 | dec_exp_n2 MINUS dec_exp_n2
			 | dec_exp_n2 OR dec_exp_n2
			 | dec_exp_n2 AND dec_exp_n2
			 | dec_exp_n3
			 ;
			 
dec_exp_n3 ::= dec_exp_n3 TIMES dec_exp_n3
			 | dec_exp_n3 DIV dec_exp_n3
			 | dec_exp_n4
			 ;
			 
dec_exp_n4 ::= MINUS dec_exp_n5 
	    	 | NOT dec_exp_n5
	    	 | PLUS dec_exp_n5
             | dec_exp_n5
             ;

dec_exp_n5 ::= NUMBER
			 | LPAREN dec_exp_n1 RPAREN
			 | UMINUS			 
			 | BOOLEAN
			 | CHAR
			 | type_struct
			 | ID LPAREN lexp RPAREN
			 ;
		