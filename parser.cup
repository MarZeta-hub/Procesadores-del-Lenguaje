
package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("prueba/input3.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIV, MENOR, MAYOR, IGUAL,UMINUS,
					LPAREN, RPAREN, DPTOS, LCORCH, RCORCH, COMA, PUNTO, 
					AND, OR, NOT, DENTERO, DREAL, DCARACTER, DBOOLEAN, 
                    RETURN, FUNCION, MIENTRAS, FINMIENTRAS, STRUCT, SI, SINO, FINSI, ENTONCES ;
terminal Double 	NUMBER;
terminal Boolean    BOOLEAN;
terminal char       CHAR;
terminal String     ID;
terminal String     IDFUNCION;

/* Non terminals */
non terminal programa, blq_sentencias, sentencia, sent_decl, sent_uso, sent_flujo,
			 asignacion, exp_list, condicional, keytipo, decl_variable, decl_struct,
			 identificado, bucle, lista_struct, funcion, uso_funcion,  lexp, exp_list2,
			 type_struct;
			 
non terminal  dec_exp_n1, dec_exp_n2, dec_exp_n3, dec_exp_n4, dec_exp_n5;

/* Precedencia */
precedence nonassoc LPAREN;	// Inserted by Eclipse plugin
precedence left NOT, AND, OR;
precedence left MAYOR, MENOR /*,GE, LE, NOTIGUAL*/;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

/* The grammar rules */

//Inicio del análisis del texto
programa ::= blq_sentencias 
		   | /*lambda*/
		   ;
 
//Para obtener si hay una sentencia (cosas ;) o es la última
blq_sentencias ::= blq_sentencias sentencia  
				 | sentencia
				 ;

sentencia ::= sent_decl 
			| sent_uso 
			| sent_flujo 
			;

sent_decl ::= decl_variable SEMI 
			| decl_struct
			;

sent_uso ::= asignacion SEMI 
		   | dec_exp_n1 SEMI
		   ;

sent_flujo ::= condicional 
			 | bucle
			 | funcion
			 ;

//Estructura de una asignacion de valores
asignacion ::= type_struct DPTOS IGUAL dec_exp_n1
			 ;
			 
type_struct	::= ID
			  | type_struct PUNTO ID
			  ;	 
			 
decl_variable ::= keytipo ID DPTOS IGUAL dec_exp_n1 
				| keytipo identificado
				;
				
identificado ::= identificado COMA ID 
			   | ID 
			   ;
				
//Estructura de una dec_exp condicional
condicional ::= SI dec_exp_n1 ENTONCES blq_sentencias FINSI
			  | SI dec_exp_n1 ENTONCES blq_sentencias SINO blq_sentencias FINSI
			  ;

//Estructura de un bucle
bucle ::= MIENTRAS dec_exp_n1 blq_sentencias FINMIENTRAS 
		;

//Tipos diversos de operandos, como nuevos structs.
keytipo ::= DENTERO 
		  | DREAL 
		  | DBOOLEAN 
		  | DCARACTER
		  | ID
		  ;
		  
funcion ::= FUNCION IDFUNCION LPAREN identificado RPAREN RETURN keytipo LCORCH blq_sentencias RCORCH
		  ;

//Estructura de un Struct
decl_struct ::= STRUCT ID LCORCH lista_struct RCORCH 
			  ;
  

lista_struct ::= decl_variable SEMI lista_struct
			   | decl_variable SEMI
			   ;

lexp ::= lexp COMA dec_exp_n1
	   | dec_exp_n1
	   ;

dec_exp_n1 ::= dec_exp_n1 MENOR dec_exp_n1
		     | dec_exp_n1 MAYOR dec_exp_n1
		     | dec_exp_n2
		     ;


dec_exp_n2 ::= dec_exp_n2 PLUS dec_exp_n2
			 | dec_exp_n2 MINUS dec_exp_n2
			 | dec_exp_n2 OR dec_exp_n2
			 | dec_exp_n2 AND dec_exp_n2
			 | dec_exp_n3
			 ;
			 
dec_exp_n3 ::= dec_exp_n3 TIMES dec_exp_n3
			 | dec_exp_n3 DIV dec_exp_n3
			 | dec_exp_n4
			 ;
			 
dec_exp_n4 ::= MINUS dec_exp_n5 
	    	 | NOT dec_exp_n5
	    	 | PLUS dec_exp_n5
             | dec_exp_n5
             ;

dec_exp_n5 ::= NUMBER
			 | LPAREN lexp RPAREN
			 | UMINUS			 
			 | BOOLEAN
			 | CHAR
			 | type_struct
			 | ID LPAREN lexp RPAREN
			 ;
		