
package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("prueba/input2.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, DIV, MENOR, MAYOR, IGUAL,UMINUS,
					LPAREN, RPAREN, DPTOS, LCORCH, RCORCH, COMA, PUNTO, 
					AND, OR, NOT, DENTERO, DREAL, DCARACTER, DBOOLEAN, 
                    RETURN, FUNCION, MIENTRAS, FINMIENTRAS, STRUCT, SI, SINO, FINSI, ENTONCES ;
terminal Double 	NUMBER;
terminal Boolean    BOOLEAN;
terminal char       CHAR;
terminal String     ID;

/* Non terminals */
non terminal programa, blq_sentencias, sentencia, sent_decl, sent_uso, sent_flujo,
			 asignacion, exp_list, condicional, keytipo, decl_variable, decl_struct,
			 identificado, bucle, lista_struct;
			 
non terminal dec_exp_n1, dec_exp_n2, dec_exp_n3, dec_exp_n4, dec_exp_n5;

/* Precedencia */
precedence nonassoc ID;	// Inserted by Eclipse plugin
precedence nonassoc SI;
precedence nonassoc SINO;
precedence left NOT, AND, OR;
precedence left MAYOR, MENOR /*,GE, LE, NOTIGUAL*/;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

/* The grammar rules */

//Inicio del análisis del texto
programa ::= blq_sentencias 
		   | /*lambda*/
		   ;
 
//Para obtener si hay una sentencia (cosas ;) o es la última
blq_sentencias ::= blq_sentencias sentencia  
				 | sentencia
				 ;

//Tipos sentencias: mediante declaracion de variables, asignacion, condicional, bloque de sentencias entre corchetes, usar una funcion, 
//declarar un struct y declarar una funcion
sentencia ::= sent_decl 
			| sent_uso 
			| sent_flujo 
			;

//Declarar una nueva variable
sent_decl ::= decl_variable SEMI 
			| decl_struct
			;

//Asignar un nuevo valora  una variable
sent_uso ::= asignacion SEMI 
		   | dec_exp_n1 SEMI

		   ;

//Flujo de condiciones o de bucles
sent_flujo ::= condicional 
			 | bucle
			 ;

//Estructura de una asignacion de valores
asignacion ::=  ID DPTOS IGUAL dec_exp_n1
			 | exp_list DPTOS IGUAL dec_exp_n1
			 ;

exp_list ::= exp_list PUNTO ID | ID
		   ;

//Estructura de una dec_exp condicional
condicional ::= SI dec_exp_n1 ENTONCES blq_sentencias FINSI
			  | SI dec_exp_n1 ENTONCES blq_sentencias SINO blq_sentencias FINSI
			  ;

//Estructura de un bucle
bucle ::= MIENTRAS dec_exp_n1 blq_sentencias FINMIENTRAS 
		;

//Estructura de una declaracion de variables
decl_variable ::= keytipo ID DPTOS IGUAL dec_exp_n1 
				| keytipo identificado
				;

//Identificacion de un ID
identificado ::= identificado COMA ID 
			   | ID ;

//Tipos diversos de operandos, como nuevos structs.
keytipo ::= DENTERO 
		  | DREAL 
		  | DBOOLEAN 
		  | DCARACTER
		  | exp_list
		  ;

//Estructura de un Struct
decl_struct ::= STRUCT ID LCORCH lista_struct RCORCH 
			  ;

lista_struct ::= decl_variable SEMI lista_struct
			   | decl_variable SEMI
			   ;

dec_exp_n1 ::= dec_exp_n1 MENOR dec_exp_n1
		     | dec_exp_n1 MAYOR dec_exp_n1
		     | dec_exp_n2
		     ;


dec_exp_n2 ::= dec_exp_n2 PLUS dec_exp_n2
			 | dec_exp_n2 MINUS dec_exp_n2
			 | dec_exp_n2 OR dec_exp_n2
			 | dec_exp_n2 AND dec_exp_n2
			 | dec_exp_n3
			 ;
			 
dec_exp_n3 ::= dec_exp_n3 TIMES dec_exp_n3
			 | dec_exp_n3 DIV dec_exp_n3
			 | dec_exp_n4
			 ;
			 
dec_exp_n4 ::= MINUS dec_exp_n5 
	    	 | NOT dec_exp_n5
             | dec_exp_n5
             ;

dec_exp_n5 ::= NUMBER
			 | LPAREN dec_exp_n1 RPAREN
			 | UMINUS			 
			 | BOOLEAN
			 | CHAR
	    	 | exp_list		 
			 ;


		  